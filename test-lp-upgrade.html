<!DOCTYPE html>
<html>
<head>
    <title>HCF LPå‡çº§æµ‹è¯•</title>
    <meta charset="UTF-8">
    <script src="https://cdn.jsdelivr.net/npm/web3@4.3.0/dist/web3.min.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 800px; 
            margin: 50px auto; 
            padding: 20px;
            background: #f5f5f5;
        }
        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .status { 
            padding: 10px; 
            margin: 10px 0; 
            border-radius: 5px;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        button {
            background: #1890ff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        button:hover { background: #40a9ff; }
        button:disabled { 
            background: #ccc; 
            cursor: not-allowed;
        }
        input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        }
        .address {
            font-family: monospace;
            background: #f0f0f0;
            padding: 5px;
            border-radius: 3px;
            word-break: break-all;
        }
    </style>
</head>
<body>
    <h1>ğŸ”§ HCF LPå‡çº§ç›´æ¥æµ‹è¯•</h1>
    
    <div class="card">
        <h2>åˆçº¦åœ°å€</h2>
        <p>HCF Token: <span class="address">0x09F320b75e6A74994713a0e4Be54eF8f09fbaEcc</span></p>
        <p>BSDT Token V2: <span class="address">0x91152b436A5b3535E01902Cf09a3c59Ab4c433BD</span></p>
        <p>Staking Contract: <span class="address">0x6E4e682Cc90124Ef66a8cfC8Fc875CF5Ee8E8a74</span></p>
    </div>

    <div class="card">
        <h2>é’±åŒ…è¿æ¥</h2>
        <button onclick="connectWallet()">è¿æ¥MetaMask</button>
        <div id="walletStatus"></div>
    </div>

    <div class="card">
        <h2>è´¦æˆ·ä¿¡æ¯</h2>
        <div id="accountInfo">è¯·å…ˆè¿æ¥é’±åŒ…</div>
    </div>

    <div class="card">
        <h2>è´¨æŠ¼ä¿¡æ¯</h2>
        <button onclick="getStakeInfo()" disabled id="btnGetStake">è·å–è´¨æŠ¼ä¿¡æ¯</button>
        <div id="stakeInfo"></div>
    </div>

    <div class="card">
        <h2>LPå‡çº§æµ‹è¯•</h2>
        <button onclick="testLPUpgrade()" disabled id="btnTestLP">æµ‹è¯•LPå‡çº§</button>
        <div id="lpTestResult"></div>
    </div>

    <div class="card">
        <h2>æ‰‹åŠ¨LPå‡çº§</h2>
        <input type="number" id="stakeIndex" placeholder="è¾“å…¥è´¨æŠ¼ç´¢å¼• (ä»0å¼€å§‹)" />
        <button onclick="manualLPUpgrade()" disabled id="btnManualLP">æ‰§è¡ŒLPå‡çº§</button>
        <div id="manualLPResult"></div>
    </div>

<script>
// åˆçº¦åœ°å€
const CONTRACT_ADDRESSES = {
    HCFToken: '0x09F320b75e6A74994713a0e4Be54eF8f09fbaEcc',
    BSDT: '0x91152b436A5b3535E01902Cf09a3c59Ab4c433BD',
    HCFStaking: '0x6E4e682Cc90124Ef66a8cfC8Fc875CF5Ee8E8a74'
};

// ABIå®šä¹‰
const STAKING_ABI = [
    {
        "inputs": [{"name": "user", "type": "address"}],
        "name": "getUserStakes",
        "outputs": [
            {
                "components": [
                    {"name": "amount", "type": "uint256"},
                    {"name": "timestamp", "type": "uint256"},
                    {"name": "lockDays", "type": "uint256"},
                    {"name": "isActive", "type": "bool"},
                    {"name": "level", "type": "uint256"},
                    {"name": "lastClaimTime", "type": "uint256"},
                    {"name": "totalClaimed", "type": "uint256"},
                    {"name": "isLP", "type": "bool"},
                    {"name": "lpBSDTAmount", "type": "uint256"},
                    {"name": "compoundCount", "type": "uint256"}
                ],
                "name": "",
                "type": "tuple[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [{"name": "index", "type": "uint256"}],
        "name": "upgradeToLP",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{"name": "user", "type": "address"}],
        "name": "getUserLevel",
        "outputs": [{"name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    }
];

const ERC20_ABI = [
    {
        "inputs": [{"name": "account", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"name": "spender", "type": "address"},
            {"name": "amount", "type": "uint256"}
        ],
        "name": "approve",
        "outputs": [{"name": "", "type": "bool"}],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"name": "owner", "type": "address"},
            {"name": "spender", "type": "address"}
        ],
        "name": "allowance",
        "outputs": [{"name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    }
];

let web3;
let userAccount;
let contracts = {};

async function connectWallet() {
    try {
        if (!window.ethereum) {
            alert('è¯·å®‰è£…MetaMaské’±åŒ…!');
            return;
        }

        // è¿æ¥é’±åŒ…
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        userAccount = accounts[0];
        
        // åˆå§‹åŒ–Web3
        web3 = new Web3(window.ethereum);
        
        // æ£€æŸ¥ç½‘ç»œ
        const chainId = await web3.eth.getChainId();
        if (chainId !== 97n) {
            alert('è¯·åˆ‡æ¢åˆ°BSCæµ‹è¯•ç½‘ (Chain ID: 97)');
            return;
        }

        // åˆå§‹åŒ–åˆçº¦
        contracts.staking = new web3.eth.Contract(STAKING_ABI, CONTRACT_ADDRESSES.HCFStaking);
        contracts.hcf = new web3.eth.Contract(ERC20_ABI, CONTRACT_ADDRESSES.HCFToken);
        contracts.bsdt = new web3.eth.Contract(ERC20_ABI, CONTRACT_ADDRESSES.BSDT);

        document.getElementById('walletStatus').innerHTML = 
            `<div class="status success">âœ… å·²è¿æ¥: ${userAccount.slice(0,6)}...${userAccount.slice(-4)}</div>`;
        
        // å¯ç”¨æŒ‰é’®
        document.getElementById('btnGetStake').disabled = false;
        document.getElementById('btnTestLP').disabled = false;
        document.getElementById('btnManualLP').disabled = false;
        
        // è‡ªåŠ¨è·å–è´¦æˆ·ä¿¡æ¯
        await getAccountInfo();
    } catch (error) {
        console.error('è¿æ¥å¤±è´¥:', error);
        document.getElementById('walletStatus').innerHTML = 
            `<div class="status error">âŒ è¿æ¥å¤±è´¥: ${error.message}</div>`;
    }
}

async function getAccountInfo() {
    try {
        const hcfBalance = await contracts.hcf.methods.balanceOf(userAccount).call();
        const bsdtBalance = await contracts.bsdt.methods.balanceOf(userAccount).call();
        const userLevel = await contracts.staking.methods.getUserLevel(userAccount).call();
        
        document.getElementById('accountInfo').innerHTML = `
            <div class="status info">
                <p>HCFä½™é¢: ${web3.utils.fromWei(hcfBalance, 'ether')} HCF</p>
                <p>BSDTä½™é¢: ${web3.utils.fromWei(bsdtBalance, 'ether')} BSDT</p>
                <p>ç”¨æˆ·ç­‰çº§: Level ${userLevel}</p>
            </div>
        `;
    } catch (error) {
        console.error('è·å–è´¦æˆ·ä¿¡æ¯å¤±è´¥:', error);
    }
}

async function getStakeInfo() {
    try {
        const stakes = await contracts.staking.methods.getUserStakes(userAccount).call();
        
        if (stakes.length === 0) {
            document.getElementById('stakeInfo').innerHTML = 
                '<div class="status info">æ‚¨è¿˜æ²¡æœ‰è´¨æŠ¼è®°å½•</div>';
            return;
        }
        
        let html = '<div class="status info">';
        stakes.forEach((stake, index) => {
            if (stake.isActive) {
                const amount = web3.utils.fromWei(stake.amount, 'ether');
                const isLP = stake.isLP;
                const lpBSDT = stake.lpBSDTAmount ? web3.utils.fromWei(stake.lpBSDTAmount, 'ether') : '0';
                
                html += `
                    <div style="border-bottom: 1px solid #ddd; padding: 10px 0;">
                        <strong>è´¨æŠ¼ #${index}</strong><br>
                        é‡‘é¢: ${amount} HCF<br>
                        ç­‰çº§: Level ${stake.level}<br>
                        çŠ¶æ€: ${isLP ? 'âœ… LPè´¨æŠ¼' : 'æ™®é€šè´¨æŠ¼'}<br>
                        ${isLP ? `BSDTæ•°é‡: ${lpBSDT} BSDT` : ''}
                        ${!isLP && Number(stake.level) >= 3 ? '<span style="color: green;">âœ¨ å¯å‡çº§ä¸ºLP</span>' : ''}
                    </div>
                `;
            }
        });
        html += '</div>';
        
        document.getElementById('stakeInfo').innerHTML = html;
    } catch (error) {
        console.error('è·å–è´¨æŠ¼ä¿¡æ¯å¤±è´¥:', error);
        document.getElementById('stakeInfo').innerHTML = 
            `<div class="status error">âŒ è·å–å¤±è´¥: ${error.message}</div>`;
    }
}

async function testLPUpgrade() {
    try {
        document.getElementById('lpTestResult').innerHTML = 
            '<div class="status info">â³ æµ‹è¯•ä¸­...</div>';
        
        // è·å–ç”¨æˆ·è´¨æŠ¼
        const stakes = await contracts.staking.methods.getUserStakes(userAccount).call();
        
        // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¯ä»¥å‡çº§çš„è´¨æŠ¼
        let upgradeableIndex = -1;
        for (let i = 0; i < stakes.length; i++) {
            if (stakes[i].isActive && !stakes[i].isLP && Number(stakes[i].level) >= 3) {
                upgradeableIndex = i;
                break;
            }
        }
        
        if (upgradeableIndex === -1) {
            document.getElementById('lpTestResult').innerHTML = 
                '<div class="status error">âŒ æ²¡æœ‰æ‰¾åˆ°å¯å‡çº§çš„è´¨æŠ¼ï¼ˆéœ€è¦Level 3+çš„æ™®é€šè´¨æŠ¼ï¼‰</div>';
            return;
        }
        
        const stake = stakes[upgradeableIndex];
        const additionalHCF = BigInt(stake.amount) * 20n / 100n;
        const requiredBSDT = additionalHCF;
        
        // æ£€æŸ¥ä½™é¢
        const hcfBalance = await contracts.hcf.methods.balanceOf(userAccount).call();
        const bsdtBalance = await contracts.bsdt.methods.balanceOf(userAccount).call();
        
        let html = '<div class="status info">';
        html += `<strong>è´¨æŠ¼ #${upgradeableIndex} LPå‡çº§éœ€æ±‚:</strong><br>`;
        html += `é¢å¤–HCF: ${web3.utils.fromWei(additionalHCF.toString(), 'ether')} HCF<br>`;
        html += `éœ€è¦BSDT: ${web3.utils.fromWei(requiredBSDT.toString(), 'ether')} BSDT<br>`;
        html += `<br><strong>å½“å‰ä½™é¢:</strong><br>`;
        html += `HCF: ${web3.utils.fromWei(hcfBalance, 'ether')} HCF `;
        html += BigInt(hcfBalance) >= additionalHCF ? 'âœ…' : 'âŒ ä¸è¶³';
        html += `<br>BSDT: ${web3.utils.fromWei(bsdtBalance, 'ether')} BSDT `;
        html += BigInt(bsdtBalance) >= requiredBSDT ? 'âœ…' : 'âŒ ä¸è¶³';
        
        // æ£€æŸ¥æˆæƒ
        const hcfAllowance = await contracts.hcf.methods.allowance(userAccount, CONTRACT_ADDRESSES.HCFStaking).call();
        const bsdtAllowance = await contracts.bsdt.methods.allowance(userAccount, CONTRACT_ADDRESSES.HCFStaking).call();
        
        html += `<br><br><strong>æˆæƒçŠ¶æ€:</strong><br>`;
        html += `HCFæˆæƒ: ${web3.utils.fromWei(hcfAllowance, 'ether')} HCF `;
        html += BigInt(hcfAllowance) >= additionalHCF ? 'âœ…' : 'âš ï¸ éœ€è¦æˆæƒ';
        html += `<br>BSDTæˆæƒ: ${web3.utils.fromWei(bsdtAllowance, 'ether')} BSDT `;
        html += BigInt(bsdtAllowance) >= requiredBSDT ? 'âœ…' : 'âš ï¸ éœ€è¦æˆæƒ';
        
        html += '</div>';
        
        // å¦‚æœä½™é¢å’Œæˆæƒéƒ½æ»¡è¶³ï¼Œæ˜¾ç¤ºå‡çº§æŒ‰é’®
        if (BigInt(hcfBalance) >= additionalHCF && BigInt(bsdtBalance) >= requiredBSDT) {
            html += `<br><button onclick="executeUpgrade(${upgradeableIndex})">æ‰§è¡Œå‡çº§ (è´¨æŠ¼ #${upgradeableIndex})</button>`;
        }
        
        document.getElementById('lpTestResult').innerHTML = html;
    } catch (error) {
        console.error('æµ‹è¯•å¤±è´¥:', error);
        document.getElementById('lpTestResult').innerHTML = 
            `<div class="status error">âŒ æµ‹è¯•å¤±è´¥: ${error.message}</div>`;
    }
}

async function executeUpgrade(index) {
    try {
        document.getElementById('lpTestResult').innerHTML += 
            '<div class="status info">â³ æ­£åœ¨æ‰§è¡Œå‡çº§...</div>';
        
        // è·å–è´¨æŠ¼ä¿¡æ¯è®¡ç®—éœ€è¦çš„é‡‘é¢
        const stakes = await contracts.staking.methods.getUserStakes(userAccount).call();
        const stake = stakes[index];
        const additionalHCF = BigInt(stake.amount) * 20n / 100n;
        const requiredBSDT = additionalHCF;
        
        // æ£€æŸ¥å¹¶æˆæƒHCF
        const hcfAllowance = await contracts.hcf.methods.allowance(userAccount, CONTRACT_ADDRESSES.HCFStaking).call();
        if (BigInt(hcfAllowance) < additionalHCF) {
            console.log('æˆæƒHCF...');
            await contracts.hcf.methods.approve(CONTRACT_ADDRESSES.HCFStaking, additionalHCF.toString()).send({ from: userAccount });
        }
        
        // æ£€æŸ¥å¹¶æˆæƒBSDT
        const bsdtAllowance = await contracts.bsdt.methods.allowance(userAccount, CONTRACT_ADDRESSES.HCFStaking).call();
        if (BigInt(bsdtAllowance) < requiredBSDT) {
            console.log('æˆæƒBSDT...');
            await contracts.bsdt.methods.approve(CONTRACT_ADDRESSES.HCFStaking, requiredBSDT.toString()).send({ from: userAccount });
        }
        
        // æ‰§è¡Œå‡çº§
        console.log('æ‰§è¡ŒLPå‡çº§...');
        const tx = await contracts.staking.methods.upgradeToLP(index).send({ from: userAccount });
        
        document.getElementById('lpTestResult').innerHTML = 
            `<div class="status success">âœ… LPå‡çº§æˆåŠŸ!<br>äº¤æ˜“å“ˆå¸Œ: ${tx.transactionHash}</div>`;
        
        // åˆ·æ–°ä¿¡æ¯
        await getStakeInfo();
        await getAccountInfo();
    } catch (error) {
        console.error('å‡çº§å¤±è´¥:', error);
        document.getElementById('lpTestResult').innerHTML = 
            `<div class="status error">âŒ å‡çº§å¤±è´¥: ${error.message}</div>`;
    }
}

async function manualLPUpgrade() {
    const index = document.getElementById('stakeIndex').value;
    if (!index && index !== 0) {
        alert('è¯·è¾“å…¥è´¨æŠ¼ç´¢å¼•');
        return;
    }
    
    try {
        await executeUpgrade(parseInt(index));
        document.getElementById('manualLPResult').innerHTML = 
            '<div class="status success">âœ… æ‰‹åŠ¨LPå‡çº§æˆåŠŸ!</div>';
    } catch (error) {
        document.getElementById('manualLPResult').innerHTML = 
            `<div class="status error">âŒ æ‰‹åŠ¨å‡çº§å¤±è´¥: ${error.message}</div>`;
    }
}

// è‡ªåŠ¨è¿æ¥é’±åŒ…ï¼ˆå¦‚æœå·²ç»æˆæƒè¿‡ï¼‰
window.addEventListener('load', async () => {
    if (window.ethereum && window.ethereum.selectedAddress) {
        await connectWallet();
    }
});
</script>
</body>
</html>